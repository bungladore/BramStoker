package mrflvhead{	import com.bramstoker.controller.events.IdleEvent;		import flash.display.Bitmap;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.*;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;		import mrflvhead.events.*;	import mrflvhead.parts.*;

	//import flash.external.ExternalInterface;		public class MisterFLVHead extends Sprite	{		private var _nc:NetConnection;		private var _ns:NetStream;		private var _vid:Video;		private var _client:Object;		private var _total_time:Number = 0;		private var _control_sp:Sprite;		private var _metadata:Object;		private var _metadata_display:MetaDataDisplay;		private var _load_progress:LoadProgress;//load progress		private var _load_pct:Number;		private var _play_progress:PlayProgress;		private var _play_pct:Number;		private var _auto_size_h:Boolean = false;		private var _auto_size_w:Boolean = false;		private var _stop_btn:StopButton;		/*var fs:FullScreen;//full screen button*/		private var _pause_btn:PauseButton;		private var _mute_btn:MuteButton;		private var _time_code:TimeCode;		private var _sound_transform:SoundTransform;		private var _paused:Boolean = false;		private var _muted:Boolean = false;		private var _current_stream:NetStream;		private var _vid_w:Number;		private var _vid_h:Number;		private var playedOnce:Boolean = false;		private var _doLoop:Boolean = false;		private var scrub_bar:Sprite;				//--------------------------------		/*		*  CONSTRUCTOR		*/		//--------------------------------				public function MisterFLVHead(w:Number = 0, h:Number = 0)		{			//trace("new mister head");			super();			// Initialize net stream			_nc = new NetConnection();			_nc.addEventListener(NetStatusEvent.NET_STATUS, onNCStatus); 			_nc.connect(null);// Not using a media server.			_ns = new NetStream(_nc);												//if either is null the video will resize based on the metadata			if(h == 0){				_auto_size_h = true;			}			if(w == 0){				_auto_size_w = true;			}						_vid_w = w;			_vid_h = h;						// Add video to stage			_vid = new Video(w,h);			addChild(_vid);						// Play video			_vid.attachNetStream(_ns);			_vid.smoothing = true;						// Add callback method for listening on			// NetStream meta data			_client = new Object();			_ns.client = _client;			_client.onMetaData = nsMetaDataCallback;						_current_stream = _ns;					}		/*//returns the net stream object				//adds the full screen pause toggle button		public function fsToggle():Sprite		{			fs = new FullScreen(this);			control_sp.addChild(fs);			return fs;		}				*/				/*public function streamVideo(streaming_str:String):void		{			_nc = new NetConnection();			_nc.connect(streaming_str);			_nc.addEventListener(NetStatusEvent.NET_STATUS, onNCStatus); 		}*/				private function onNCStatus(e:NetStatusEvent):void		{			switch (e.info.code)		    {		        case "NetStream.Play.StreamNotFound":		         dispatchEvent(new Event("streamFailed"));		         break;		        case "NetConnection.Connect.Success":		         trace("success");				 dispatchEvent(new Event("VIDEO_STARTED", true));		         playedOnce = true;		         break;		         		        case "NetStream.Play.Stop":		         trace("NET STREAM STOPPED");				 dispatchEvent(new Event("VIDEO_COMPLETE", true));				 dispatchEvent(new IdleEvent(IdleEvent.ENABLE_IDLE, true));				 if(playedOnce && _doLoop){				 	trace("looping");				 	_current_stream.seek(0);				 }				 break;		    }		}		public function loop():void		{			_doLoop = true;		}		public function streamMe():void		{			_ns = new NetStream(_nc);			_vid.attachNetStream(_ns);			_current_stream = _ns;						_vid.width = _vid_w;			_vid.height = _vid_h;						if(_play_progress){				removeEventListener(Event.ENTER_FRAME, updatePlayProgress);				_play_progress.reset();			}			if(_load_progress){				removeEventListener(Event.ENTER_FRAME, updateLoadProgress);				_load_progress.reset();			}			if(_pause_btn){				_pause_btn.visible = false;			}			if(_stop_btn){				_stop_btn.visible = false;			}						dispatchEvent(new Event("streamConnected"));		}				public function closeStream():void		{			if(_current_stream != null){				_current_stream.close();			}			_nc.connect(null)			_ns = new NetStream(_nc);			_vid.attachNetStream(_ns);			_current_stream = _ns;						_client = new Object();			_ns.client = _client;			_client.onMetaData = nsMetaDataCallback;						if(_play_progress){				addEventListener(Event.ENTER_FRAME, updatePlayProgress, false, 0, true);				_play_progress.reset();			}			if(_load_progress){				addEventListener(Event.ENTER_FRAME, updateLoadProgress, false, 0, true);				_load_progress.reset();			}						if(_pause_btn){				_pause_btn.visible = true;			}			if(_stop_btn){				_stop_btn.visible = true;			}		}					//--------------------------------		/*		*  LOADS THE VIDEO		*/		//--------------------------------				public function loadVideo(video_str:String):void		{				_vid.clear();			if(_paused){				//unpause();				_pause_btn.play();			}			_current_stream.play(video_str);			_current_stream.addEventListener(NetStatusEvent.NET_STATUS, onNCStatus);			if(_load_progress){				resetLoad();			}			if(_play_progress)			{				addEventListener(Event.ENTER_FRAME, updatePlayProgress, false, 0, true);			}			//when the video loads -- disable the user idle listener			dispatchEvent(new IdleEvent(IdleEvent.DISABLE_IDLE, true));		}				public function ppReset():void		{			scrub_bar.x = _play_progress.x + 825 + _play_progress._mask.x;		}				public function killVideo(reset_scrub:Boolean = true):void		{			_current_stream.close();			_vid.clear();			trace("RESET SCRUB " + reset_scrub);			if(_play_progress)			{				_play_progress.reset();				removeEventListener(Event.ENTER_FRAME, updatePlayProgress);				if(reset_scrub){					scrub_bar.x = _play_progress.x + 825 + _play_progress._mask.x;				}			}			//when the video is closed -- start the user idle listener			dispatchEvent(new IdleEvent(IdleEvent.ENABLE_IDLE, true));		}				//--------------------------------		/*		*  PLAY PROGRESS FUNCTIONALITY		*/		//--------------------------------				public function addPlayProgress(play_progress:Object = null, scrub:Sprite = null):PlayProgress		{			_play_progress = new PlayProgress(play_progress);			scrub_bar = scrub;			//scrub_bar.x = _play_progress.x + 825 + _play_progress._mask.x;			return _play_progress;		}				public function addSilentProgress():void		{			addEventListener(Event.ENTER_FRAME, silentPlayProgress, false, 0, true);		}				private function updatePlayProgress(e:Event):void		{			if(_total_time){				_play_pct = _current_stream.time/_total_time;				_play_progress.updateProgress(_play_pct);				/*if(_play_pct >= .99)				{					removeEventListener(Event.ENTER_FRAME, updatePlayProgress);					dispatchEvent(new Event("videoCompleted"));									}*/			}			//trace("PLAY PROGRESS LISTENER IS FIRING ", scrub_bar.x);			scrub_bar.x = _play_progress.x + 830 + _play_progress._mask.x;// + _play_progress.width;		}				public function get paused():Boolean		{			return _paused;		}				private function silentPlayProgress(e:Event):void		{			var play_pct:Number = _current_stream.time/_total_time;			if(play_pct >= 1 && _current_stream.time > 1 && _total_time > 1)			{				removeEventListener(Event.ENTER_FRAME, silentPlayProgress);				dispatchEvent(new Event("videoCompleted"));			}		}				//--------------------------------		/*		*  LOAD PROGRESS FUNCTIONALITY		*/		//--------------------------------				public function addLoadProgress(load_progress:Object = null):LoadProgress		{			trace("load the progress " + load_progress);			_load_progress = new LoadProgress(load_progress);			addEventListener(Event.ENTER_FRAME, updateLoadProgress, false, 0, true);			_load_progress.addEventListener(ScrubEvent.ON_SCRUB_HERE, scrubToHere, false, 0, true);			return _load_progress;		}				private function updateLoadProgress(e:Event):void		{			if(_current_stream.bytesTotal){				_load_pct = _current_stream.bytesLoaded/_current_stream.bytesTotal;				_load_progress.updateProgress(_load_pct);				if(_load_pct >= 1)				{					dispatchEvent(new Event("loadCompleted"));					removeEventListener(Event.ENTER_FRAME, updateLoadProgress);				}			}		}				private function scrubToHere(e:ScrubEvent):void		{			var seek_time:Number = e.params.scrub_pct*_total_time;			_current_stream.seek(seek_time);		}				private function resetLoad():void		{			addEventListener(Event.ENTER_FRAME, updateLoadProgress, false, 0, true);		}				//--------------------------------	    /*		*  PLAY/PAUSE TOGGLE FUNCTIONALITY		*/		//--------------------------------				//adds the play pause toggle button		public function addPauseButton(pause_btn:DisplayObject, play_btn:DisplayObject):PauseButton		{			_pause_btn = new PauseButton(pause_btn, play_btn);			_pause_btn.addEventListener("VIDEO_PAUSED", pause);			_pause_btn.addEventListener("VIDEO_UNPAUSED", unpause);			return _pause_btn;		}				//toggles pause		public function pause(e:Event = null):void		{			trace("MR FLV IS DOING  A PAUSE");			_current_stream.pause();			dispatchEvent(new Event("VIDEO_PAUSED", true));			//			dispatchEvent(new IdleEvent(IdleEvent.ENABLE_IDLE, true));			_paused = true;		}				//starts the video again - like a play button, but you don't need to pass a string		public function unpause(e:Event = null):void		{			if(_paused){				trace("MR FLV VIDEO IS UNPAUSED");				_current_stream.togglePause();				dispatchEvent(new Event("VIDEO_UNPAUSED", true));				//				dispatchEvent(new IdleEvent(IdleEvent.DISABLE_IDLE, true));				_paused = false;			}		}				//--------------------------------		/*		*  STOP FUNCTIONALITY		*/		//--------------------------------				//adds the stop button		public function addStopButton(stop_btn:Bitmap):StopButton		{			_stop_btn = new StopButton(stop_btn);			_stop_btn.addEventListener("stopVideo", stop);			return _stop_btn;		}				//stops the video and fires off a stopped event		public function stop(e:Event = null):void		{			trace("VIDEO STOPPED MRFLV");			/*if(_pause_btn){//so the pause button toggle displays correctly				_pause_btn.pause();			}else{				pause();			}*/			//_current_stream.removeEventListener(NetStatusEvent.NET_STATUS, onNCStatus);			pause();			_current_stream.seek(0);			killVideo(true);			//dispatchEvent(new Event("VIDEO_STOPPED", true));		}				//--------------------------------	    /*		*  MUTE/UNMUTE TOGGLE FUNCTIONALITY		*/		//--------------------------------				//adds the play pause toggle button		public function addMuteButton(mute_btn:Bitmap, unmute_btn:Bitmap):MuteButton		{			_sound_transform = new SoundTransform();			_current_stream.soundTransform = _sound_transform;			_mute_btn = new MuteButton(mute_btn, unmute_btn);			_mute_btn.addEventListener("muteVideo", mute);			_mute_btn.addEventListener("unmuteVideo", unmute);			return _mute_btn;		}				//toggles pause		private function mute(e:Event = null):void		{			_sound_transform.volume = 0;			_current_stream.soundTransform= _sound_transform;			dispatchEvent(new Event("videoMuted"));			_muted = true;		}				//starts the video again - like a play button, but you don't need to pass a string		private function unmute(e:Event = null):void		{			if(_muted){				_sound_transform.volume = 1;				_current_stream.soundTransform= _sound_transform;				dispatchEvent(new Event("videoUnmuted"));				_muted = false;			}		}						//--------------------------------		/*		*  TIMECODE FUNCTIONALITY		*/		//--------------------------------				//adds the stop button		public function addTimeCode(text_format:Object = null):TimeCode		{			_time_code = new TimeCode(text_format);			startTimeCode();			addEventListener("videoPaused", stopTimeCode, false, 0, true);			addEventListener("videoUnpaused", startTimeCode, false, 0, true);			return _time_code;		}				//stops the video and fires off a stopped event		public function updateTimeCode(e:Event = null):void		{			_time_code.updateTime(getCurrentTime());		}				//stops the video and fires off a stopped event		public function stopTimeCode(e:Event = null):void		{			removeEventListener(Event.ENTER_FRAME, updateTimeCode);		}				//stops the video and fires off a stopped event		public function startTimeCode(e:Event = null):void		{			addEventListener(Event.ENTER_FRAME, updateTimeCode, false, 0, true);		}				//--------------------------------		/*		*  METADATA - AUTOMATED PROPERTIES		*/		//--------------------------------		//adds the meta data display		public function addMetaDataDisplay():MetaDataDisplay		{			_metadata_display = new MetaDataDisplay();			addEventListener("MDATA", updateMetaDisplay, false, 0, true);			return _metadata_display;		}				private function updateMetaDisplay(e:Event):void		{			_metadata_display.updateDisplay(_metadata);		}				//returns the metadata from the flv that is loaded		private function nsMetaDataCallback(mdata:Object):void		{			//_client.onMetaData = null;//nsMetaDataCallback;			_total_time = mdata.duration;			trace("Metadata duration " + mdata.duration);						_metadata = mdata;						//trace("got the meta data callback " + _total_time);						//checks and resizes if both/w/h are not valid (i.e. 0)... then resizes accordingly			if(_auto_size_h && _auto_size_w){				_vid.height = mdata.height;				_vid.width = mdata.width;				trace("1");			}else if(_auto_size_h){				_vid.height = mdata.height*_vid_w/mdata.width;				_vid.width = _vid_w;				trace("2");			}else if(_auto_size_w){				_vid.width = mdata.width*_vid_h/mdata.height;				_vid.height = _vid_h;				trace("3");			}else{				_vid.width = _vid_w;				_vid.height = _vid_h;				trace("4", _vid);			}						dispatchEvent(new Event("MDATA"));		}				//--------------------------------		/*		*  GET PROPERTIES		*/		//--------------------------------				//returns the net stream object		public function getStream():NetStream		{			return _current_stream;		}				//returns the sprite that holds the controls		/*public function getControls():Sprite		{			return _control_sp;		}*/				//returns the current time in playback		public function getCurrentTime():Number		{			return _current_stream.time;		}				//returns the current time in playback		public function getTotalTime():Number		{			return _total_time;		}			}}